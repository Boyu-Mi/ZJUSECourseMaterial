# Java应用技术

2021-2022 秋冬 翁恺

## Lecture01 

### scanner

用于读取输入

```java
import java.util.Scanner;;
public class A {
    public static void main(String [] args){
        Scanner in = new Scanner(System.in);
        int x = in.nextInt();
        System.out.println("Hello" + x);
        in.close();
    }
}
```

`in.next()`读入一个单词，以空格，tab，换行区分；

`in.nextLine()`读入一整行

`"Hello" + x`事实上是调用`x`的`toString`方法将其转换为字符串。

#### 变量初始化

与c++不同，在Java中声明

```java
String s;
```

时，并不会创造一个字符串对象，而是创造它的引用（指针）。所以在对象赋值时，只是简单的指针赋值（浅拷贝）。

#### 创建对象

使用`new`运算符

```java
String s = new String("a string");
```

## String APIs

规则：如果`+`两端有一个字符串，另一个不是，则另一个也要调用`toString`方法将其转为字符串。

`+`从左到右计算，因此

```java
"abc" + 1 + 2 == "abc12";
1 + 2 + "abc" == "3abc";
```

判断相等：`equals()`

`s1 == s2`:  判断s1 s2 是否指向一个对象。

`s1.equals()` 判断s1 s2指向对象的内容是否相等。

```java
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2); //true
    }
}
```

```java
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hel" + "lo";
        System.out.println(s1 == s2); //true
    }
}
```

```c++
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hel";
        s2 += "lo";
        System.out.println(s1 == s2); //false
    }
}
```

```java
public class A{
    public static void main(String [] args){
        String s1 = new String("hello");
        String s2 = new String("hello");
        System.out.println(s1 == s2); //false
    }
}
```

```java
public class A{
    public static void f(String s){
        String s2 = "hello";
        System.out.println(s2 == s);
    }
    public static void main(String [] args){
        String s1 = "hello";
        f(s1);//true
    }
}
```

- 使用相同字面量创造的对象是同一个对象，即使它们可能不在一个函数内，而使用`new`创造的对象则是不同的两个。

- 而如果使用了 `String s2 = "hel" + "lo";`这样的静态运算，

  编译器会自动优化为`String s2 = "hello";`



`compareTo()`比较字符串大小

`charAT(int index)`获取在index位置的字符

`substring(int beginindex, int endindex)`获取子串，但不包含`endindex`（经典）

String是一种**Immutable**(不可修改)类型：

```java
public class A{
    public static void f(String s){
        String s2 = "hello";
        System.out.println(s2 == s);
    }
    public static void main(String [] args){
        String s1 = "   hello  ";
        String s2 = s1.trim();
        System.out.println("##" + s1 + "##");    //##   hello  ##
        System.out.println("##" + s2 + "##");	//##hello##
    }
}
```

实现不可修改特性的方法：String的所有方法都无法修改自身。

好处：如果多个字符串内容相同，只需要让它们指向同一个字面量即可。

`String.valueOf()`可以将整数，浮点数等转换为字符串。 更好的办法：`"" + integer `

`String.format()`: 格式化字符串

## Lecture02

### Java 基础类

byte char short long float double， 没有unsigned

### 类的比较

#### ==

比较两个指针是否指向了同一个对象

```java
Integer i1 = 128;
Integer i2 = 128;
System.out.println(i1 == i2);//false
Integer i11 = 127;
Integer i12 = 127;
System.out.println(i11 == i12);//true
```

输出不同，原因在于Java为-128~127内的整数提前创建了对象，所以所有指针指向的对象相同。

要比较是否相等，需要重载`equals()`函数，写法：

```java
class Value{
    int i;
    @Override
    public boolean equals(Object obj){
        if (obj instanceof Value) {
            Value v = (Value) obj;
            return v.i == i;
        }
        return false;
    }
}
```

### this

返回当前操作对象的引用

```java
public class Leaf {
    private int i = 0;
    Leaf increment(){
        i++;
        return this;
    }
    void print(){
        System.out.println("i = " + i);
    }
    public static void main(String [] args){
        Leaf x = new Leaf();
        x.increment().increment().increment().increment().print();//i = 4 
    }
}
```

### 代理构造函数

使用`this`调用构造函数（但是只能调用一次）

`this`的两个用法：

```java
public class Flower {
    private int petalCount = 0;
    private String s = new String("null");
    Flower(int petals){
        petalCount = petals;
        System.out.println(
            "Constructor w/ int arg only, petalCount = "
        	+ petalCount);
    }

    Flower(String ss){
        s = ss;
        System.out.println(
            "Constructor w/ String arg only, s = "
        	+ s);
    }

    Flower(String s, int petals){
        this(petals);//用法1
        //this(s);//cannot call twice!!
        this.s = s;//用法2
        System.out.println("int and string");
    }

    public static void main(String [] args){
        Flower f1 = new Flower("aaa", 1);
    }
}
```

### finalize

系统需要清理垃圾的时候，会调用那些需要被清理的对象的finalize函数。

### 成员初始化

- Java确保了任何变量在使用前都被正确初始化。

- c++中，如果没有为对象赋初值，则其初值为其所在内存块上原先的值。而Java中初值默认为`0`。

定义初始化：类声明中可以直接写初值，例：

```java
class Measurement{
    boolean b = true;
    char c = 'x';
    int i = 47;
}
```

也可以在定义时new一个对象：

```java
class Measurement{
    Depth o = new Depth();//Depth的构造早于Measurement
}
```

定义初始化早于类的构造函数（类似c++初始化列表）

也可以在定义时调用其他函数，这些函数的参数甚至可以是本类内已经定义的成员。

```java
class CInit{
    int i = f();
    int k = g(i);//OK
}
```

```java
class CInit{
    //int j = g(i);ERROR, i must be defined before j.
    int i = f();
}
```

初始化顺序与变量定义顺序相同。

### Static data initialization

- 静态成员是类的成员，而不是对象的

- 在类的装载（load）过程中被初始化

  静态初始化块：在类装载的时候执行：

 ```java
 static {
     System.out.println("loading!");
 }
 ```

每个类构造时的顺序：装载静态成员，装载非静态成员，构造函数。

### Package

通过import可以导入一整个库或库中的一些成员，如

```java
import java.util.*;
import java.util.Vector;
```

### compliation unit 

- 每个.java文件是一个编译单元，根据其中类名生成若干个.class文件。
- 如果.java文件中一个类是public，则文件名必须与这个类名相同。这也说明一个文件中最多一个public类。
- 最好一个文件一个类

### Java的package机制

- 需要在源代码中声明属于某个包
- 创建名称与包名相同的文件夹并把该类的.class文件放进去

```java
//Hello.java
package hello;
public class Hello{
    //...
}
```

要成功编译运行，需要

```bash
javac .\Hello.java
mkdir hello
mv Hello.class hello
java hello.Hello
```

### access specifiers

与c++不同之处：

- 在每一个成员前面都要加上public or private
- protected：同一个包&子类可以访问
- friendly：default，同一个包可以访问
- 访问限制可以针对整个类

## Lecture03

### Inheritance

syntax：

```java
class ThisClass extends Superclass {
    //class body
}
```

构造顺序：与c++相同

如果子类构造函数需要参数：

- c++中使用初始化列表传参
- Java使用`super()`传参

```java
public class Chess extends BoardGame{
    Chess(){
        super(11);
        //...
    }
}
```

### Name hide

c++中在子类中对父类的函数进行了重载或子类中override了父类重载函数的其中一个，则父类的函数就不存在了

但Java中**没有**这个设计错误，子类中的函数依然存在。

### Override

- 在c++中，只有基类函数有`virtual`关键字时才会产生`Override`现象，但Java中，只要返回值、函数名和参数列表相同，就自动产生重写。
- 父类与子类的同名变量之间没有任何关系，父类的函数访问父类自己的变量，子类亦然。
- 在c++中，如果在子类构造中调用了重写函数，实际调用的是父类版本的函数，但Java中，调用的是子类版本的函数。

```java
/* Son.java
*
*/
class PrivateFather {
    private int i = 10;
    {
        System.out.println("father member");
    }

    public PrivateFather(){
        System.out.println("Father()'s i = " + i);
        increment();
    }
    public void increment(){
        System.out.println("Father's i = " + i);
        i++;
    }

}

public class Son extends PrivateFather{
    private int i = 20;
    {
        System.out.println("son member");
    }

    public Son(){
        System.out.println("Son()'s i = " + i);
        increment();
    }
    public void increment(){
        System.out.println("Son's i = " + i);
        i--;
    }
    public static void main(String[] args){
        Son s = new Son();
    }
}
```

输出

`
father member
Father()'s i = 10
Son's i = 0
son member
Son()'s i = 20
Son's i = 20
`

解释：首先调用父类构造，第一个输出的`i`是父类的`10`，第二个输出的`i`来自`increment`函数。这个函数被重写了，调用的是子类的`increment`，而此时子类的`i`还没有被构造，所以值为`0`。然后调用子类的构造函数，输出的`i`为子类的`20`。

- 含有静态成员的执行顺序：父类静态成员-子类静态成员-父类定义初始化-父类构造-子类定义初始化-子类构造

### 纯虚函数和抽象类

Java关键字 `abstract`

用于1.表示一个类不能创造对象 2.一个函数没有body（用分号结尾即可）

```java
abstract class Instrument {
    int i;
    public abstract void play();
}
```

- 只要有一个抽象函数，那么这个类必须是抽象类
- 一个抽象类不一定要有抽象函数

#### Interface

- 所有的方法都是`public`的
- 所有数据成员都是`public static final`的（字面量）

```java
interface instrument{
    int i = 5;//默认public static final
    void play();//默认public
    String what();
    void adjust();
}
```

class，interface，enum编译后都会产生`.class`文件

- 对interface的继承使用`implements`关键字
- interface可以继承自另一个interface，使用`extends`关键字，也允许多继承

- 对类的继承和接口的实现可以同时进行，比如

  ```java
  class A extends B implements C, D, E{
      //...
  }
  ```

### Inner classes

- 在一个类里定义的类

- 编译后外部类产生.class文件，每个内部类也会产生，且文件名为"外部类名$内部类名"。

  ```java
  public class Parcel1 {
      class Contents{
          
      }
      
      class Destination{
          
      }
  }
  ```

  ```bash
  rm *.class
  javac Parcel1.java
  ls *.class
  ```

  结果为`Parcel1$Contents.class`， `Parcel1$Destination.class`, `Parcel1.class`

  .class文件独立的好处：可以分别装载，装载外部类时不一定需要同时装载内部类

由于定义在外部类中，内部类和成员变量在某些方面具有相似性。因此，其可以加上public等修饰词，如果定义成static，则和外部类一起装载。

#### 内部类用法

在外部类的成员函数中可以直接使用:

```java
public void ship(){
    Contents c = new Contents();
    Destination d = new Destination();
}
```

但非`static`的静态类不能在main函数中使用（静态函数不能使用非静态变量）

可以通过内部类将类的实现，构造等隐藏。Parcel3.java

内部类也可以定义在函数里，但仅在作用域内有效，编译后的.class文件名为

```
Parcel4$1pDestinaiton
```

`1`代表着在外部类中这个内部类在函数里定义的顺序（可以在成员函数里定义多次）

#### 匿名类

```java
class AnonymousDemo {
   public void createClass() {class Polygon {
   public void display() {
      System.out.println("在 Polygon 类内部");
   }
}

class AnonymousDemo {
   public void createClass() {

      // 创建的匿名类继承了 Polygon 类
      Polygon p1 = new Polygon() {
         public void display() {
            System.out.println("在匿名类内部。");
         }
      };
      p1.display();
   }
}

class Main {
   public static void main(String[] args) {
       AnonymousDemo an = new AnonymousDemo();
       an.createClass();
   }
}
//输出“在匿名类内部”
```

如果父类构造函数需要参数，在定义匿名子类时，直接将参数写入`new`操作的括号内。

在匿名子类里调用父类函数：

```java
super.func_name(args);
```

内部类里也可以使用外部函数的本地变量或外部类的成员变量，但这些变量必须定义为final或者事实上final。

可以在匿名类里放置一个定义初始化块起到事实上的构造函数的作用

内部类中也可以使用外部类的成员变量，即使其是私有的。

与成员变量类似，成员类不具有override关系

### Enums

格式：

```java
public enum Name{
   A,B,C,D 
}
```

遍历：

```java
for(Name n : Name.values()){
    //....
}
```

可以枚举对象：

```java
public enum Planet{
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6);
    private final double mass;
    private final double radius;
    Planet (double mass, double radius){
        this.mass = mass;
        this.radius = radius;
    }
    public static final double G = 6.67300E-11;
    public double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    public double surfaceWeight(double otherMass){
        return otherMass * surfaceGravity();
    }
    public static void main(String []args){
        double earthWeight = 70.0;
        double mass = earthWeight/EARTH.surfaceGravity();
        for(Planet p : Planet.values()){
            System.out.printf("Your weight on %s is %f%n",
                                p, p.surfaceWeight(mass));
        }
    }
}
```

也可以在枚举中定义匿名类。

```java
public enum Operation {
    PLUS {double eval(double x, double y){return x + y;}},
    MINUS {double eval(double x, double y){return x - y;}},
    TIMES {double eval(double x, double y){return x * y;}},
    DIVIDE {double eval(double x, double y){return x / y;}};

    abstract double eval(double x, double y);

    public static void main(String [] args){
        double x = 5;
        double y = 5.0;
        for(Operation o : Operation.values()){
            System.out.printf(
                "%f %s %f = %f\n", x, o, y, o.eval(x, y));
        }
    }
}
```

## Lecture04

回放生成中

## Lecture05

### Generic Containers

Java 将数组看做一个类型，数组不是一段内存，而是一个对象。

```java
int[] names = new int[4];
names[0] = 101;
```

数组有一个成员变量`length`,返回数组内元素的数量。

Java会对下标做检查，如果无效就抛出异常（关闭下标检查可以提速）

当一个数组被创建，数组内每个元素都是对象指针

#### for-each loop

```
for(<type><variable> : <array>){
	//do something on variable...
	//cannot modify elements in the array
}
```

`for-each`不能修改数组内指针指向的位置，但可以借助指针修改指向对象内部的某些值。

#### matrix

```java
int [][]a = new int[3][4];
```

- a is an array of int[3];

一维数组：N行1列

二维数组：N行M列，实际是M个大小为N的一维数组的数组。

#### collection 容器

##### ArrayList

```java
import java.util.ArrayList;
ArrayList<String> notes = new ArrayList<String>();
```

- put in

```java
public boolean add(E o);
public void add(int index, E element);
```

- remove

```java
public boolean add(Object o);//按下标从小到大顺序查找，删除第一个
public E add(int index);//删除指定位置的元素并返回其指针
```

- 下标运算

```java
notes.get(index);
```

- size

```java
size();
```

- Iterator

```java
Iterator <String> it = notes.interator();
while(it.hasNext()){
    System.out.println(it.next());//打印当前，迭代器后移
}
```

小tips：判空时，isEmpty()性能比size() != 0好

- 容器转数组

```java
Object[] toArray();
```

##### List(interface)

2 implements: ArrayList, LinkedList

##### Set(interface)

HashSet(), TreeSet()

```java
HashSet<String> myset = new HashSet<String>();
myset.add("one");
myset.add("two");
Iterator<String> it = myset.iterator();
while(it.hasNext()){
    //do something
}
```



##### 性能比较

![image-20220706140115490](E:\typorapic\image-20220706140115490.png)

##### map

```java
HashMap<String, String> phonebook = new HashMap<String, String>();
phonebook.put("Lisa Jones", "(402) 4536 4647");
String phoneNumber = phoneBook.get("Lisa Jones");
```

### Generics 泛型

类：

```java
public interface List<E> {
    void add(E x);
    Iterator<E> iterator();
}

public interface Iterator<E> {
    E next();
    boolean hasNext();
}
```

函数：将类型写在返回值类型前

```java
public <T>int indexOf(T[] arr, T elm) {
    //...
}
```

泛型的解决方案：

- c++使用模板解决（不是oop）
- Java使用oop的方式解决，表现为泛型类中有一个隐藏的成员变量：类型，泛型函数有一个隐藏参数：类型，（类型也是对象）

### Generic and Subtyping

```java
List<String> ls = new ArrayList<String>();
//List<Object> lo = ls;//ERROR
```

> 如果Foo是Bar的子类， G是某种泛型，G \<Foo\> 不是G\<Bar\>的子类。

### Wildcards

通配符：`?`

```java
public void drawAll(List<? extends Shape> shapes){
    for(Shape s : shapes){
        s.draw(this);
    }
}
```

`? extends Shape`含义为：任何继承了`Shape`的类型。如此做，既可以方便将`List<Circle>`等不是`List<Shape>`子类的类作为参数输入，也可以防止参数为那些元素类型不是`Shape`子类的列表（如`String`）。

### instanceof

用于判断一个对象是不是一个类的对象。

### pitfall

```java
System.out.println(true ? Integer.valueOf(1) : Double.valueOf(2));
```

`1.0`

三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为Object，输出时使用多态调用重写的toString();即Double包装类的toString();

### pitfall

```java
System.out.println(true ? Integer.valueOf(1) : Double.valueOf(2));
```

`1.0`

三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型），再自动装箱为Object，输出时使用多态调用重写的toString();即Double包装类的toString();

### Exception & IO

抛出的异常必须是`Throwable`的类的对象，一般情况下是`Exception`子类。

如果某个函数可能抛出异常，则必须声明其可能抛出的异常类型。

```java
void f() throws TooBig, TooSmall, DivZero {//...
void f() {//保证不抛出任何异常
```

- 声明不代表此函数一定会抛出这些异常，即使函数可能抛出上述异常也是可以的。

- 运行时异常(run-time exception)不需要声明，数组下标越界，空指针等异常几乎会存在在每个函数中，因此不需要声明。

  ![image-20220710080740676](E:\typorapic\image-20220710080740676.png)

- catch any exception:

  ```java
  catch(Exception e){}
  ```

#### 异常的相关函数

```java
public class ExceptionMethods {
    public static void f() throws Exception {
        throw new Exception("Here's my Exception.");
    }

    public static void main(String[] args){
        try{
            f();
        }catch(Exception e){
            System.out.println("e.getMessage:" + e.getMessage());
            System.out.println("e.toString:" + e.toString());
            System.out.println("e.printStackTrace:");
            e.printStackTrace();
        }
    }
}
/*
e.getMessage:Here's my Exception.
e.toString:java.lang.Exception: Here's my Exception.     
e.printStackTrace:
java.lang.Exception: Here's my Exception.
        at ExceptionMethods.f(ExceptionMethods.java:3)   
        at ExceptionMethods.main(ExceptionMethods.java:8)
*/
```

如果需要将catch到的异常再抛出：

in c++：

```c++
catch(Exception &e){
    throw;
}
```

in Java:

```java
catch(Exception e){
    throw e;
}
```

### finally

```java
try {
    
} catch(A a1) {
    
} catch(B b1) {
    
} finally {
    //Activities that happen every time 
}
```

### override

- 在子类override父类非构造函数的时候，**不能**抛出比父类更多的异常。原因：

如果

```java
class A {
    void f() throws ex1 {
        throw ex1;
    }
}

public class B extends A {
    void f() throw ex1, ex2 {
        throw ex1, ex2;
    }
    void ff(A p) {
        try {
            p.f();
        }catch(ex1 e){
            //...
        }
    }
}
```

B类`f`函数会抛出比A更多的异常，如果在`ff`函数中传入的参数实际为B类变量，且抛出了`ex2`，则程序无法对其进行处理。所以编译时就必须确保重写函数不会抛出更多类型的异常。

- 子类的构造函数必须声明父类构造可能抛出的异常，在此基础上还能添加自己的异常。
- 当子类的某个函数有多个来源（继承，实现了多个类/接口且多个父类/接口中含有同一个函数）时，子类重写的此函数抛出的异常是来源函数异常的交集。

### 流

#### InputStream

```java
class GetInput{
    public static void main(String[] args){
        byte buffer[] = new byte[256];
        try{
            int bytes = System.in.read(buffer, 0, 256);
            String str = new String(buffer, 0, bytes);
            System.out.println(str + ":" + bytes + ":" + str.length());
        }
    }
}
```

这部分太抽象了。。没有代码属实听不懂
