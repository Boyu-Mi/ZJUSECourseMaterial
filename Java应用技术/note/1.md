# Java应用技术

2021-2022 秋冬 翁恺

## Lecture01 

### scanner

用于读取输入

```java
import java.util.Scanner;;
public class A {
    public static void main(String [] args){
        Scanner in = new Scanner(System.in);
        int x = in.nextInt();
        System.out.println("Hello" + x);
        in.close();
    }
}
```

`in.next()`读入一个单词，以空格，tab，换行区分；

`in.nextLine()`读入一整行

`"Hello" + x`事实上是调用`x`的`toString`方法将其转换为字符串。

#### 变量初始化

与c++不同，在Java中声明

```java
String s;
```

时，并不会创造一个字符串对象，而是创造它的引用（指针）。所以在对象赋值时，只是简单的指针赋值（浅拷贝）。

#### 创建对象

使用`new`运算符

```java
String s = new String("a string");
```

## String APIs

规则：如果`+`两端有一个字符串，另一个不是，则另一个也要调用`toString`方法将其转为字符串。

`+`从左到右计算，因此

```java
"abc" + 1 + 2 == "abc12";
1 + 2 + "abc" == "3abc";
```

判断相等：`equals()`

`s1 == s2`:  判断s1 s2 是否指向一个对象。

`s1.equals()` 判断s1 s2指向对象的内容是否相等。

```java
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hello";
        System.out.println(s1 == s2); //true
    }
}
```

```java
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hel" + "lo";
        System.out.println(s1 == s2); //true
    }
}
```

```c++
public class A{
    public static void main(String [] args){
        String s1 = "hello";
        String s2 = "hel";
        s2 += "lo";
        System.out.println(s1 == s2); //false
    }
}
```

```java
public class A{
    public static void main(String [] args){
        String s1 = new String("hello");
        String s2 = new String("hello");
        System.out.println(s1 == s2); //false
    }
}
```

```java
public class A{
    public static void f(String s){
        String s2 = "hello";
        System.out.println(s2 == s);
    }
    public static void main(String [] args){
        String s1 = "hello";
        f(s1);//true
    }
}
```

- 使用相同字面量创造的对象是同一个对象，即使它们可能不在一个函数内，而使用`new`创造的对象则是不同的两个。

- 而如果使用了 `String s2 = "hel" + "lo";`这样的静态运算，

  编译器会自动优化为`String s2 = "hello";`



`compareTo()`比较字符串大小

`charAT(int index)`获取在index位置的字符

`substring(int beginindex, int endindex)`获取子串，但不包含`endindex`（经典）

String是一种**Immutable**(不可修改)类型：

```java
public class A{
    public static void f(String s){
        String s2 = "hello";
        System.out.println(s2 == s);
    }
    public static void main(String [] args){
        String s1 = "   hello  ";
        String s2 = s1.trim();
        System.out.println("##" + s1 + "##");    //##   hello  ##
        System.out.println("##" + s2 + "##");	//##hello##
    }
}
```

实现不可修改特性的方法：String的所有方法都无法修改自身。

好处：如果多个字符串内容相同，只需要让它们指向同一个字面量即可。

`String.valueOf()`可以将整数，浮点数等转换为字符串。 更好的办法：`"" + integer `

`String.format()`: 格式化字符串

## Lecture02

### Java 基础类

byte char short long float double， 没有unsigned

### 类的比较

#### ==

比较两个指针是否指向了同一个对象

```java
Integer i1 = 128;
Integer i2 = 128;
System.out.println(i1 == i2);//false
Integer i11 = 127;
Integer i12 = 127;
System.out.println(i11 == i12);//true
```

输出不同，原因在于Java为-128~127内的整数提前创建了对象，所以所有指针指向的对象相同。

要比较是否相等，需要重载`equals()`函数，写法：

```java
class Value{
    int i;
    @Override
    public boolean equals(Object obj){
        if (obj instanceof Value) {
            Value v = (Value) obj;
            return v.i == i;
        }
        return false;
    }
}
```

### this

返回当前操作对象的引用

```java
public class Leaf {
    private int i = 0;
    Leaf increment(){
        i++;
        return this;
    }
    void print(){
        System.out.println("i = " + i);
    }
    public static void main(String [] args){
        Leaf x = new Leaf();
        x.increment().increment().increment().increment().print();//i = 4 
    }
}
```

### 代理构造函数

使用`this`调用构造函数（但是只能调用一次）

`this`的两个用法：

```java
public class Flower {
    private int petalCount = 0;
    private String s = new String("null");
    Flower(int petals){
        petalCount = petals;
        System.out.println(
            "Constructor w/ int arg only, petalCount = "
        	+ petalCount);
    }

    Flower(String ss){
        s = ss;
        System.out.println(
            "Constructor w/ String arg only, s = "
        	+ s);
    }

    Flower(String s, int petals){
        this(petals);//用法1
        //this(s);//cannot call twice!!
        this.s = s;//用法2
        System.out.println("int and string");
    }

    public static void main(String [] args){
        Flower f1 = new Flower("aaa", 1);
    }
}
```

### finalize

系统需要清理垃圾的时候，会调用那些需要被清理的对象的finalize函数。

### 成员初始化

- Java确保了任何变量在使用前都被正确初始化。

- c++中，如果没有为对象赋初值，则其初值为其所在内存块上原先的值。而Java中初值默认为`0`。

定义初始化：类声明中可以直接写初值，例：

```java
class Measurement{
    boolean b = true;
    char c = 'x';
    int i = 47;
}
```

也可以在定义时new一个对象：

```java
class Measurement{
    Depth o = new Depth();//Depth的构造早于Measurement
}
```

定义初始化早于类的构造函数（类似c++初始化列表）

也可以在定义时调用其他函数，这些函数的参数甚至可以是本类内已经定义的成员。

```java
class CInit{
    int i = f();
    int k = g(i);//OK
}
```

```java
class CInit{
    //int j = g(i);ERROR, i must be defined before j.
    int i = f();
}
```

初始化顺序与变量定义顺序相同。

### Static data initialization

- 静态成员是类的成员，而不是对象的

- 在类的装载（load）过程中被初始化

  静态初始化块：在类装载的时候执行：

 ```java
 static {
     System.out.println("loading!");
 }
 ```

每个类构造时的顺序：装载静态成员，装载非静态成员，构造函数。

### Package

通过import可以导入一整个库或库中的一些成员，如

```java
import java.util.*;
import java.util.Vector;
```

### compliation unit 

- 每个.java文件是一个编译单元，根据其中类名生成若干个.class文件。
- 如果.java文件中一个类是public，则文件名必须与这个类名相同。这也说明一个文件中最多一个public类。
- 最好一个文件一个类

### Java的package机制

- 需要在源代码中声明属于某个包
- 创建名称与包名相同的文件夹并把该类的.class文件放进去

```java
//Hello.java
package hello;
public class Hello{
    //...
}
```

要成功编译运行，需要

```bash
javac .\Hello.java
mkdir hello
mv Hello.class hello
java hello.Hello
```

### access specifiers

与c++不同之处：

- 在每一个成员前面都要加上public or private
- protected：同一个包&子类可以访问
- friendly：default，同一个包可以访问
- 访问限制可以针对整个类

## Lecture03

### Inheritance

syntax：

```java
class ThisClass extends Superclass {
    //class body
}
```

构造顺序：与c++相同

如果子类构造函数需要参数：

- c++中使用初始化列表传参
- Java使用`super()`传参

```java
public class Chess extends BoardGame{
    Chess(){
        super(11);
        //...
    }
}
```

### Name hide

c++中在子类中对父类的函数进行了重载或子类中override了父类重载函数的其中一个，则父类的函数就不存在了

但Java中**没有**这个设计错误，子类中的函数依然存在。

### Override

- 在c++中，只有基类函数有`virtual`关键字时才会产生`Override`现象，但Java中，只要返回值、函数名和参数列表相同，就自动产生重写。
- 父类与子类的同名变量之间没有任何关系，父类的函数访问父类自己的变量，子类亦然。
- 在c++中，如果在子类构造中调用了重写函数，实际调用的是父类版本的函数，但Java中，调用的是子类版本的函数。

```java
/* Son.java
*
*/
class PrivateFather {
    private int i = 10;
    {
        System.out.println("father member");
    }

    public PrivateFather(){
        System.out.println("Father()'s i = " + i);
        increment();
    }
    public void increment(){
        System.out.println("Father's i = " + i);
        i++;
    }

}

public class Son extends PrivateFather{
    private int i = 20;
    {
        System.out.println("son member");
    }

    public Son(){
        System.out.println("Son()'s i = " + i);
        increment();
    }
    public void increment(){
        System.out.println("Son's i = " + i);
        i--;
    }
    public static void main(String[] args){
        Son s = new Son();
    }
}
```

输出

`
father member
Father()'s i = 10
Son's i = 0
son member
Son()'s i = 20
Son's i = 20
`

解释：首先调用父类构造，第一个输出的`i`是父类的`10`，第二个输出的`i`来自`increment`函数。这个函数被重写了，调用的是子类的`increment`，而此时子类的`i`还没有被构造，所以值为`0`。然后调用子类的构造函数，输出的`i`为子类的`20`。

- 含有静态成员的执行顺序：父类静态成员-子类静态成员-父类定义初始化-父类构造-子类定义初始化-子类构造

### 纯虚函数和抽象类

Java关键字 `abstract`

用于1.表示一个类不能创造对象 2.一个函数没有body（用分号结尾即可）

```java
abstract class Instrument {
    int i;
    public abstract void play();
}
```

- 只要有一个抽象函数，那么这个类必须是抽象类
- 一个抽象类不一定要有抽象函数

#### Interface

- 所有的方法都是`public`的
- 所有数据成员都是`public static final`的（字面量）

```java
interface instrument{
    int i = 5;
    void play();//可以不用写public
    String what();
    void adjust();
}
```

