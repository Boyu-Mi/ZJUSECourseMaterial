## 第二周作业

### 设计思路

输入十六进制机器码，将其转化为二进制，首先判断指令类型，然后根据机器码相应位置的值判断具体指令及寄存器、立即数等参数。

### 使用方法

打开unassembler.exe文件，每行中输入一个机器码对应的8位十六进制数（32位整数），输出对应的汇编指令。

若无对应指令，输出“NULL”

### R类型指令

前6位为0，指令功能由后6位决定。

#### 可反汇编指令：

and or xor nor slt sltu syscall jr srav srlv sllv sra srl sll 

#### 测试数据&结果

```
1095024
and $t0, $t1, $t2
0319d025
or $t8, $t9, $k0
0319d026
xor $t8, $t9, $k0
02119027
nor $s0, $s1, $s2
0260a100
sll $s3, $s4, 4
0253A004
sllv $s2, $s3, $s4
02008842
srl $s0, $s1
02329806
srlv $s1, $s2, $s3
02209103
sra $s1, $s2
02119007
srav $s0, $s1, $s2
03400008
jr $k0
0000000c
syscall
```



### I类型指令

前6位为操作符，后16位为立即数

#### 可反汇编指令：

 lui lw lwx lh slti sltiu andi xori beq bne

#### 测试数据&结果

```
10871111
beq $a0, $a3, 4369
14431111
bne $v0, $v1, 4369
8a11000f
lwx $s0, 15($s1)
3c11000f
lui $s1, 15
8e53008f
lw $s2, 143($s3)
8653000f
lh $s2, -32753($s3)
2a511111
slti $s2, $s1, -28399
30431111
andi $v0, $v1, 4369
38411111
xori $v0, $at, 4369
2ffe1111
sltiu $ra, $fp, 4369
```

### J类型指令

前6位为操作数，后26位为地址

#### 可反汇编指令：

j bgezal jal 

#### 测试数据&结果

```
08444445
j 4473925
06511111
bgezal $s2, 4369
0C888888
jal 8947848
```

## 实验心得

在编写反汇编程序时，需要先区分指令类型，再根据类型从机器码的不同区域提取相应参数的值。

对于不同指令，应注意其汇编指令的格式，且应增强代码复用性，使代码更加简洁。

